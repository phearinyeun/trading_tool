import os
import time
import requests
from datetime import datetime, timedelta
from tradingview_ta import TA_Handler, Interval
from dotenv import load_dotenv
from pathlib import Path
from requests.exceptions import RequestException, ConnectionError, Timeout

# ===============================
# 1ï¸âƒ£ Load .env reliably
# ===============================
env_path = Path(__file__).parent / ".env"
if not env_path.exists():
    raise FileNotFoundError(f"âŒ .env file not found at {env_path}")

load_dotenv(dotenv_path=env_path)

# Telegram
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
CHAT_ID = os.getenv("CHAT_ID")

# Multiple symbols - remove empty entries
SYMBOLS = [s.strip() for s in os.getenv("SYMBOLS", "").split(",") if s.strip()]
TV_SYMBOLS = [s.strip() for s in os.getenv("TV_SYMBOLS", "").split(",") if s.strip()]

# Debug: show loaded symbols
print("âœ… Loaded SYMBOLS:", SYMBOLS)
print("âœ… Loaded TV_SYMBOLS:", TV_SYMBOLS)

if not SYMBOLS or not TV_SYMBOLS:
    raise ValueError("âŒ SYMBOLS and TV_SYMBOLS must be set in .env")

if len(SYMBOLS) != len(TV_SYMBOLS):
    raise ValueError("âŒ SYMBOLS and TV_SYMBOLS must have the same number of entries")

# Bot settings
CURRENCY = os.getenv("CURRENCY", "usd")
SLEEP_TIME = int(os.getenv("SLEEP_TIME", 300))
VOLATILITY = float(os.getenv("VOLATILITY", 0.005))

# Interval mapping
INTERVAL_STR = os.getenv("INTERVAL", "1h")
INTERVAL_MAPPING = {
    "1m": Interval.INTERVAL_1_MINUTE,
    "5m": Interval.INTERVAL_5_MINUTES,
    "15m": Interval.INTERVAL_15_MINUTES,
    "30m": Interval.INTERVAL_30_MINUTES,
    "1h": Interval.INTERVAL_1_HOUR,
    "2h": Interval.INTERVAL_2_HOURS,
    "4h": Interval.INTERVAL_4_HOURS,
    "1d": Interval.INTERVAL_1_DAY,
}
INTERVAL = INTERVAL_MAPPING.get(INTERVAL_STR.lower(), Interval.INTERVAL_1_HOUR)

# Track last signals per TV symbol
last_signals = {tv: None for tv in TV_SYMBOLS}

# Jakarta timezone offset
JAKARTA_OFFSET = timedelta(hours=7)

# ===============================
# 2ï¸âƒ£ Telegram Helper
# ===============================
def send_telegram(message):
    if not TELEGRAM_BOT_TOKEN or not CHAT_ID:
        print("âš ï¸ Telegram not configured. Skipping send.")
        return
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    payload = {"chat_id": CHAT_ID, "text": message, "parse_mode": "HTML"}
    try:
        requests.post(url, data=payload, timeout=10)
    except Exception as e:
        print("âŒ Telegram send error:", e)

# ===============================
# 3ï¸âƒ£ CoinGecko Price Fetch
# ===============================
def get_price_data(symbol):
    if not symbol:
        return None
    url = "https://api.coingecko.com/api/v3/simple/price"
    params = {
        "ids": symbol,
        "vs_currencies": CURRENCY,
        "include_24hr_change": "true"
    }
    try:
        r = requests.get(url, params=params, timeout=10)
        r.raise_for_status()
        return r.json()[symbol]
    except (RequestException, KeyError) as e:
        print(f"âŒ CoinGecko error for {symbol}: {e}")
        return None

# ===============================
# 4ï¸âƒ£ TradingView TA
# ===============================
def get_ta_signal(tv_symbol):
    if not tv_symbol:
        return None
    try:
        handler = TA_Handler(
            symbol=tv_symbol,
            screener="crypto",
            exchange="BINANCE",
            interval=INTERVAL
        )
        analysis = handler.get_analysis()
        return analysis.summary
    except Exception as e:
        print(f"âŒ TradingView error for {tv_symbol}: {e}")
        return None

# ===============================
# 5ï¸âƒ£ Compute Entry, SL, TP
# ===============================
def compute_levels(price, signal):
    entry = price
    if signal == "BUY":
        sl = round(price * (1 - VOLATILITY), 4)
        tp1 = round(price * (1 + VOLATILITY * 2), 4)
        tp2 = round(price * (1 + VOLATILITY * 4), 4)
    elif signal == "SELL":
        sl = round(price * (1 + VOLATILITY), 4)
        tp1 = round(price * (1 - VOLATILITY * 2), 4)
        tp2 = round(price * (1 - VOLATILITY * 4), 4)
    else:  # HOLD
        sl = tp1 = tp2 = price
    return entry, sl, tp1, tp2

# ===============================
# 6ï¸âƒ£ Analyze Each Symbol
# ===============================
def analyze_symbol(coin_symbol, tv_symbol):
    global last_signals

    price_data = get_price_data(coin_symbol)
    ta_data = get_ta_signal(tv_symbol)

    if not price_data or not ta_data:
        print(f"âš ï¸ Skipping {coin_symbol}/{tv_symbol} due to missing data.")
        return

    price = price_data[CURRENCY]
    change = price_data[f"{CURRENCY}_24h_change"]
    ta_signal = ta_data.get("RECOMMENDATION", "HOLD")

    # Determine decision
    decision = "HOLD"
    reason = "Sideways market."
    confidence = "Low"

    if ta_signal == "BUY" and change > 1:
        decision = "BUY"
        reason = "Strong uptrend (TA + 24h growth)"
        confidence = "High"
    elif ta_signal == "SELL" and change < -1:
        decision = "SELL"
        reason = "Downtrend (TA + 24h drop)"
        confidence = "High"

    entry, sl, tp1, tp2 = compute_levels(price, decision)

    # Compute expected profit %
    if decision == "BUY":
        expected_profit1 = ((tp1 - entry) / entry) * 100
        expected_profit2 = ((tp2 - entry) / entry) * 100
    elif decision == "SELL":
        expected_profit1 = ((entry - tp1) / entry) * 100
        expected_profit2 = ((entry - tp2) / entry) * 100
    else:
        expected_profit1 = expected_profit2 = 0

    # Compute suggested exit advice
    if decision == "BUY":
        if price >= tp2:
            exit_advice = "Take profit now (TP2 reached)"
        elif price >= tp1:
            exit_advice = "Partial profit suggested (TP1 reached)"
        elif price <= sl:
            exit_advice = "Stop loss triggered, exit immediately"
        else:
            exit_advice = "Hold, trend positive"
    elif decision == "SELL":
        if price <= tp2:
            exit_advice = "Take profit now (TP2 reached)"
        elif price <= tp1:
            exit_advice = "Partial profit suggested (TP1 reached)"
        elif price >= sl:
            exit_advice = "Stop loss triggered, exit immediately"
        else:
            exit_advice = "Hold, trend negative"
    else:
        exit_advice = "No action, sideways market"

    # Convert UTC to Jakarta time
    jakarta_time = datetime.utcnow() + JAKARTA_OFFSET

    # Send alert if signal changed
    if last_signals[tv_symbol] != decision:
        # Prevent repeated HOLD alerts
        if decision == "HOLD" and last_signals[tv_symbol] == "HOLD":
            return

        msg = f"""
ğŸš€ <b>Market Alert</b> ğŸš€
â° <b>{jakarta_time.strftime('%Y-%m-%d %H:%M:%S')} WIB</b>
ğŸ’¹ <b>Symbol:</b> {tv_symbol} ({coin_symbol})
ğŸ’° <b>Price:</b> {price} {CURRENCY.upper()}
ğŸ“Š <b>24h Change:</b> {change:.2f}%
ğŸ§  <b>TA Signal:</b> {ta_signal}
ğŸ“ˆ <b>Decision:</b> {decision} ({confidence} confidence)
ğŸ“ <b>Reason:</b> {reason}
âš¡ <b>Levels:</b>
    Entry: {entry}
    Stop Loss: {sl}
    Take Profit 1: {tp1} (~{expected_profit1:.2f}% profit)
    Take Profit 2: {tp2} (~{expected_profit2:.2f}% profit)
â±ï¸ <b>Suggested Entry Time:</b> {jakarta_time.strftime('%H:%M:%S WIB')}
â¹ï¸ <b>Suggested Exit:</b> {exit_advice}
"""
        send_telegram(msg)
        last_signals[tv_symbol] = decision
        print(f"âœ… Sent alert for {tv_symbol}: {decision}")
    else:
        print(f"{tv_symbol} â†’ {decision} (no new alert)")

# ===============================
# 7ï¸âƒ£ Main Loop
# ===============================
def main():
    print("ğŸš€ Multi-Symbol Market Analyzer with Profit & Exit Advice (Jakarta time) Started...")
    while True:
        try:
            for coin, tv in zip(SYMBOLS, TV_SYMBOLS):
                analyze_symbol(coin, tv)
        except (ConnectionError, Timeout) as e:
            print("ğŸŒ Network error:", e)
        except Exception as e:
            print("âŒ Unexpected error:", e)
        time.sleep(SLEEP_TIME)

if __name__ == "__main__":
    main()
